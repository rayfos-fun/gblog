---
layout: post
title: "演算法与资料结构的「实用性」：从学校考试、LeetCode 到真实工作"
lang: zh-cn
permalink: /zh-cn/post/20251008/
---
身为一位软体工程师，我完整走过了这个充满争议的循环：学校学习 (学不好) → 面试刷题 (被迫学) → 实际工作 (很少用)。

这个话题的核心疑问始终是：刷 LeetCode 学到的高效演算法，在真实工作中到底有没有用？

# 学校与面试：从「硬背」到「体悟」

老实说，我在学校学习演算法和资料结构时，学得并不扎实。那时没有什麽学习动力，仅仅是为了应付考试，我不理解为什麽要学那些複杂的结构，例如不知道什麽场景下会需要红黑树 (Red-Black Tree)的存在，只能硬着头皮死记硬背。

直到我为了准备面试开始刷 LeetCode，才真正有了切身体会：

1. 时间複杂度的惩罚： 在刷题过程中，如果使用了错误的资料结构或演算法，程式码就会因为超时 (Time Limit Exceeded) 而无法通过。这让我真切体会到：效率 (Performance) 是有价值的。

2. 知识的重新学习： 当我意识到某些特定的演算法（如二分搜寻、动态规划）和资料结构（如哈希表、堆）可以「应用」在哪些类型的题目上时，这才等于是对知识进行了实用性的重新学习。

对我来说，**面试刷题不是考试，而是一场高效的应用教学。**它让我将抽象的知识，与具体的「如何在时限内解决问题」的需求连结起来。

# 真实工作：效率不是第一要务

然而，当我真正进入业界，处理实际的业务需求时，我发现了一个残酷的现实：在大部分时间裡，刷 LeetCode 学到的极致效率的演算法和资料结构，几乎都用不上。

为什麽？

因为实际的软体开发工作，主要重点在于处理 Business Logic（业务逻辑）的需求。重点是流程的正确性（Correctness），而不是极致的运行效率：

* 输入规模： 大部分的业务流程，其输入数据并不是百万级别的即时海量数据。

* 计算需求： 很少需要秒级、甚至毫秒级的即时运算结果。很多报表或数据处理，就算是一个一个慢慢算，结果出来后摆在那裡，隔三差五有人来校验、审核、然后拿去使用。

在这种环境下，追求 O(logN) 级别的效率优化，远不如追求程式码的可读性、可维护性、以及流程的正确性重要。一个 O(N<sup>2</sup>) 的暴力解法，只要能让人看懂、流程不出错，可能比一个极致优化的但难以理解的 O(NlogN) 方案更受青睐。

# 刷题的真正价值：沟通与效率的训练

那麽，刷题真的没有用了吗？当然不是。

我认为刷 LeetCode 学到的东西，它的价值体现在两个层面：

1. 对面试的「高报酬率」投资

    毫无疑问，对于通过技术面试，它依然是最有效的工具。刷题的过程，是在训练你**写程式码能够「快、狠、准」**的能力。这份基础编程的熟练度，对日常工作中的程式码撰写效率还是有所帮助的。

2. 面试中的「王道」：沟通能力

    作为一个曾担任面试官的人，除了基本的编程功力之外，我更看重的是沟通能力。顶尖的演算法能力固然重要，但如果在面试中：
    * 无法清晰地理解面试官真正的需求。
    * 无法在开始动手前，透过提问确认边界条件和限制。
    * 无法在沟通中让解决方案不偏离正确的方向。

    那麽，就算可以写出完美高效的程式码，依然有可能被我刷掉。

真正的王道是：能将抽象的技术问题，转化为清晰的沟通语言，并在互动中导向最合适的解决方案。这展现了工程师在实际工作中，面对模煳需求时的业务判断力和协作能力。

总结来说：演算法是软体工程师的武术套路，虽然不常在街上使用，但它锻鍊了你的内功；而沟通，才是你在真实世界中取得胜利的核心战略。