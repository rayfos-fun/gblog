---
layout: post
title: "演算法與資料結構的「實用性」：從學校考試、LeetCode 到真實工作"
lang: zh-tw
permalink: /zh-tw/post/20251008/
---
身為一位軟體工程師，我完整走過了這個充滿爭議的循環：學校學習 (學不好) → 面試刷題 (被迫學) → 實際工作 (很少用)。

這個話題的核心疑問始終是：刷 LeetCode 學到的高效演算法，在真實工作中到底有沒有用？

# 學校與面試：從「硬背」到「體悟」

老實說，我在學校學習演算法和資料結構時，學得並不紮實。那時沒有什麼學習動力，僅僅是為了應付考試，我不理解為什麼要學那些複雜的結構，例如不知道什麼場景下會需要紅黑樹 (Red-Black Tree)的存在，只能硬著頭皮死記硬背。

直到我為了準備面試開始刷 LeetCode，才真正有了切身體會：

1. 時間複雜度的懲罰： 在刷題過程中，如果使用了錯誤的資料結構或演算法，程式碼就會因為超時 (Time Limit Exceeded) 而無法通過。這讓我真切體會到：效率 (Performance) 是有價值的。

2. 知識的重新學習： 當我意識到某些特定的演算法（如二分搜尋、動態規劃）和資料結構（如哈希表、堆）可以「應用」在哪些類型的題目上時，這才等於是對知識進行了實用性的重新學習。

對我來說，**面試刷題不是考試，而是一場高效的應用教學。**它讓我將抽象的知識，與具體的「如何在時限內解決問題」的需求連結起來。

# 真實工作：效率不是第一要務

然而，當我真正進入業界，處理實際的業務需求時，我發現了一個殘酷的現實：在大部分時間裡，刷 LeetCode 學到的極致效率的演算法和資料結構，幾乎都用不上。

為什麼？

因為實際的軟體開發工作，主要重點在於處理 Business Logic（業務邏輯）的需求。重點是流程的正確性（Correctness），而不是極致的運行效率：

* 輸入規模： 大部分的業務流程，其輸入數據並不是百萬級別的即時海量數據。

* 計算需求： 很少需要秒級、甚至毫秒級的即時運算結果。很多報表或數據處理，就算是一個一個慢慢算，結果出來後擺在那裡，隔三差五有人來校驗、審核、然後拿去使用。

在這種環境下，追求 O(logN) 級別的效率優化，遠不如追求程式碼的可讀性、可維護性、以及流程的正確性重要。一個 O(N<sup>2</sup>) 的暴力解法，只要能讓人看懂、流程不出錯，可能比一個極致優化的但難以理解的 O(NlogN) 方案更受青睞。

# 刷題的真正價值：溝通與效率的訓練

那麼，刷題真的沒有用了嗎？當然不是。

我認為刷 LeetCode 學到的東西，它的價值體現在兩個層面：

1. 對面試的「高報酬率」投資

    毫無疑問，對於通過技術面試，它依然是最有效的工具。刷題的過程，是在訓練你**寫程式碼能夠「快、狠、準」**的能力。這份基礎編程的熟練度，對日常工作中的程式碼撰寫效率還是有所幫助的。

2. 面試中的「王道」：溝通能力

    作為一個曾擔任面試官的人，除了基本的編程功力之外，我更看重的是溝通能力。頂尖的演算法能力固然重要，但如果在面試中：
    * 無法清晰地理解面試官真正的需求。
    * 無法在開始動手前，透過提問確認邊界條件和限制。
    * 無法在溝通中讓解決方案不偏離正確的方向。

    那麼，就算可以寫出完美高效的程式碼，依然有可能被我刷掉。

真正的王道是：能將抽象的技術問題，轉化為清晰的溝通語言，並在互動中導向最合適的解決方案。這展現了工程師在實際工作中，面對模糊需求時的業務判斷力和協作能力。

總結來說：演算法是軟體工程師的武術套路，雖然不常在街上使用，但它鍛鍊了你的內功；而溝通，才是你在真實世界中取得勝利的核心戰略。