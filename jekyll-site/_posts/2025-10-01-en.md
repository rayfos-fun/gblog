---
layout: post
title: "The Engineer's Anchor: Why I'm Obsessed with the World Beneath High-Level Code"
lang: en
permalink: /en/post/20251001/
---
As a software engineer, my daily work involves high-level programming languages, cloud services, and abstract frameworks. Honestly, these tools are incredibly convenient, letting me deliver features quickly —- a testament to the efficiency of modern software development.

Yet, deep down, a persistent voice always asks: "How does this really work?"

This curiosity and dedication to understanding the underlying principles might be rooted in my MBTI (specifically the S-trait); I'm someone who pays extreme attention to the details and mechanics of things I care about.

# My "Hardcore" Knowledge Base: From Logic Gates to Assembly

Looking back at my technical journey, I've found that this "old school" knowledge is vital for my mental health and my identity as an engineer:

* Electrical Engineering & Logic Gates: In college, we started with CMOS transistors and learned how they combine into AND/OR/NOT logic gates. This taught me that all complex computations are built from the simplest binary switches —- it was like learning the "atomic structure" of the digital world.

* Firmware & Assembly: My first job as a BIOS Firmware Engineer gave me hands-on experience with Assembly Language. This was the golden bridge that allowed me to see exactly how high-level languages like C++ or Python interface with the underlying CPU hardware.

Now, when I write a line of abstract code, my brain automatically decomposes it into machine instructions, memory access, and even logic gate signals. This ability to "know the how and why" is the bedrock of my technical understanding.

# The Ultimate Testing Ground: When Hobbies Meet Principles

For me, understanding the low-level logic isn't just a job requirement; it’s a passion project. I still fondly recall a particularly "hardcore" experiment:

Without consulting any tutorial, I used the Redstone circuit system in the game Minecraft to manually build a seven-segment display from scratch.

This was essentially simulating real-world logic gates and memory cells inside a game. It took time, but when that giant virtual display lit up the correct number, the satisfaction of validating the fundamental principle was unmatched by writing any typical application code.

# Finding "Grounding" in the Age of Abstraction

I admit that in this era of AI-assisted development and heavily abstracted cloud services, the Assembly I learned won't directly help me fix a current business bug.

However, the psychological power it gives me is invaluable:

* Eliminating Uncertainty: When a high-level framework or API throws an opaque error, I don't panic. I know the ultimate underlying principles are stable and traceable. This gives me a solid psychological anchor.

* Boosting Confidence: Having a complete knowledge map—from the very bottom (hardware) to the top (application)—allows me to diagnose system issues more confidently and communicate effectively with engineers across different specialized domains.

This dedication to "principle and detail" is not just a technical preference; it's how I, as an engineer, find security and control in a rapidly changing technological world.

Do you share this obsession with low-level technology? How do these "old school" insights influence your current work and mindset?
