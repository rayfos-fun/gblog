{% assign locale = site.data.locales[page.lang] %}
{% assign game = locale.tools.loop_timer %}

{% assign title_text = game.title %}
{% assign label_seconds = game.label_seconds %}
{% assign label_color = game.label_color %}
{% assign btn_add = game.btn_add %}
{% assign btn_start = locale.start %}
{% assign btn_pause = locale.pause %}
{% assign btn_reset = locale.reset %}
{% assign btn_clear = game.btn_clear %}
{% assign text_phase = game.text_phase %}
{% assign text_loop_count = game.text_loop_count %}
{% assign text_empty_list = game.text_empty_list %}
{% assign msg_please_enter = game.msg_please_enter %}

<style>
  /* Scoped styles for the game container to avoid conflict */
  .game-container {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 600px;
    margin: 20px auto;
    background-color: #f9f9f9;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    padding: 24px;
    text-align: center;
    box-sizing: border-box;
  }

  .game-container * {
    box-sizing: border-box;
  }

  .game-header {
    margin-bottom: 20px;
    color: #333;
    font-size: 1.5rem;
    font-weight: bold;
  }

  /* Input Section */
  .input-group {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 20px;
    padding: 15px;
    background: #fff;
    border-radius: 8px;
    border: 1px solid #eee;
  }

  .game-input {
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-size: 1rem;
  }

  input[type="number"] {
    width: 140px;
  }

  input[type="color"] {
    width: 50px;
    height: 40px;
    padding: 2px;
    cursor: pointer;
  }

  .btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
    color: white;
    font-weight: 500;
  }

  .btn:active {
    transform: scale(0.98);
  }

  .btn-add { background-color: #3498db; }
  .btn-start { background-color: #2ecc71; }
  .btn-pause { background-color: #f39c12; }
  .btn-reset { background-color: #95a5a6; }
  .btn-clear { background-color: #e74c3c; margin-top: 10px; font-size: 0.9rem;}

  .btn:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }

  /* Segment List */
  .segment-list {
    list-style: none;
    padding: 0;
    margin: 0 0 20px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    min-height: 40px;
  }

  .segment-item {
    background: #fff;
    border: 1px solid #ddd;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .color-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
  }

  .empty-msg {
    color: #999;
    font-style: italic;
    font-size: 0.9rem;
  }

  /* Timer Display */
  .timer-box {
    background-color: #333;
    color: white;
    padding: 40px;
    border-radius: 12px;
    margin-bottom: 20px;
    transition: background-color 0.5s ease; /* Smooth color transition */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
  }

  .timer-digits {
    font-size: 4rem;
    font-family: 'Courier New', Courier, monospace;
    font-weight: bold;
    line-height: 1;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  }

  .timer-info {
    margin-top: 10px;
    font-size: 1.1rem;
    opacity: 0.9;
  }

  .controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
  }
</style>

<div class="game-container">
  <div class="game-header">{{ title_text }}</div>

  <div class="input-group">
    <input type="number" id="inp-seconds" class="game-input" placeholder="{{ label_seconds }}" min="1">
    <input type="color" id="inp-color" class="game-input" value="#3498db" title="{{ label_color }}">
    <button id="btn-add" class="btn btn-add">{{ btn_add }}</button>
  </div>

  <div id="segment-list" class="segment-list">
    <span class="empty-msg">{{ text_empty_list }}</span>
  </div>

  <div id="timer-box" class="timer-box">
    <div id="timer-display" class="timer-digits">00:00</div>
    <div class="timer-info">
      <span id="phase-display">--</span> | 
      <span id="loop-display">{{ text_loop_count }}: 0</span>
    </div>
  </div>

  <div class="controls">
    <button id="btn-toggle" class="btn btn-start">{{ btn_start }}</button>
    <button id="btn-reset" class="btn btn-reset">{{ btn_reset }}</button>
  </div>
  
  <button id="btn-clear" class="btn btn-clear">{{ btn_clear }}</button>
</div>

<script>
  (function() {
    // State variables
    var segments = [];
    var currentSegmentIndex = 0;
    var remainingTime = 0;
    var isRunning = false;
    var timerInterval = null;
    var loopCount = 0;

    // DOM Elements
    var inpSeconds = document.getElementById('inp-seconds');
    var inpColor = document.getElementById('inp-color');
    var btnAdd = document.getElementById('btn-add');
    var listContainer = document.getElementById('segment-list');
    
    var timerBox = document.getElementById('timer-box');
    var timerDisplay = document.getElementById('timer-display');
    var phaseDisplay = document.getElementById('phase-display');
    var loopDisplay = document.getElementById('loop-display');
    
    var btnToggle = document.getElementById('btn-toggle');
    var btnReset = document.getElementById('btn-reset');
    var btnClear = document.getElementById('btn-clear');

    // Add Segment
    btnAdd.addEventListener('click', function() {
      var sec = parseInt(inpSeconds.value);
      var color = inpColor.value;

      if (isNaN(sec) || sec <= 0) {
        alert("{{ msg_please_enter }}");
        return;
      }

      segments.push({ seconds: sec, color: color });
      renderSegments();
      
      // Reset input
      inpSeconds.value = '';
      inpSeconds.focus();
      
      // If this is the first segment added, initialize display
      if (segments.length === 1) {
        resetLogic();
      }
    });

    // Toggle Start/Pause
    btnToggle.addEventListener('click', function() {
      if (segments.length === 0) return;

      if (isRunning) {
        pauseTimer();
      } else {
        startTimer();
      }
    });

    // Reset
    btnReset.addEventListener('click', function() {
      pauseTimer();
      resetLogic();
    });

    // Clear All
    btnClear.addEventListener('click', function() {
      pauseTimer();
      segments = [];
      renderSegments();
      resetLogic();
      timerBox.style.backgroundColor = '#333';
      timerDisplay.innerText = "00:00";
      phaseDisplay.innerText = "--";
    });

    function startTimer() {
      isRunning = true;
      btnToggle.innerText = "{{ btn_pause }}";
      btnToggle.className = "btn btn-pause";
      
      // Lock inputs
      btnAdd.disabled = true;
      btnClear.disabled = true;

      // Start interval
      timerInterval = setInterval(tick, 1000);
    }

    function pauseTimer() {
      isRunning = false;
      btnToggle.innerText = "{{ btn_start }}";
      btnToggle.className = "btn btn-start";
      clearInterval(timerInterval);
      
      // Unlock inputs
      btnAdd.disabled = false;
      btnClear.disabled = false;
    }

    function resetLogic() {
      currentSegmentIndex = 0;
      loopCount = 0;
      if (segments.length > 0) {
        remainingTime = segments[0].seconds;
        updateUI(segments[0]);
      } else {
        remainingTime = 0;
      }
      updateLoopDisplay();
    }

    function tick() {
      // Decrease time
      remainingTime--;

      // Check if phase finished
      if (remainingTime < 0) {
        // Move to next segment
        currentSegmentIndex++;
        
        // Loop check
        if (currentSegmentIndex >= segments.length) {
          currentSegmentIndex = 0;
          loopCount++;
          updateLoopDisplay();
        }

        // Set new time
        var currentSeg = segments[currentSegmentIndex];
        remainingTime = currentSeg.seconds;
        updateUI(currentSeg);
        
        // Immediate visual update for the first second of new phase
        // (Wait 1s for next tick would feel lagging)
        // Actually, we usually show the full seconds first, then count down.
        // So at T=0, we switch immediately to New Time.
        // My logic: 1 -> 0 -> Switch -> New Time. 
        // Correct flow: 1 -> 0 (beep/change) -> New Time - 1.
        
        // Let's adjust logic:
        // Tick happens. 
        // Display shows X. 
        // Tick -> X becomes X-1.
        // If X-1 < 0 -> Switch phase, reset remainingTime to NewSeconds. 
        // But we want to see the new seconds immediately?
        // Let's stick to: At 0, we switch.
        
        // Correction: The display logic below handles showing current remainingTime.
        // If we just switched, remainingTime is full.
      }
      
      // Update Display
      if (segments.length > 0) {
        updateUI(segments[currentSegmentIndex]);
      }
    }

    function updateUI(segment) {
      // Format Time
      var displaySec = remainingTime;
      // Optional: Add HH:MM logic if needed, but simple seconds requested.
      // Let's do neat formatting if > 60
      var m = Math.floor(displaySec / 60);
      var s = displaySec % 60;
      var timeStr = (m < 10 ? "0"+m : m) + ":" + (s < 10 ? "0"+s : s);

      timerDisplay.innerText = timeStr;
      
      // Update Phase Text
      phaseDisplay.innerText = "{{ text_phase }} " + (currentSegmentIndex + 1);
      
      // Update Background Color
      timerBox.style.backgroundColor = segment.color;
      
      // Ensure text contrast (simple logic: white text usually works on colors)
      // If needed, we could calculate luminance, but keeping it simple.
    }
    
    function updateLoopDisplay() {
      loopDisplay.innerText = "{{ text_loop_count }}: " + loopCount;
    }

    function renderSegments() {
      listContainer.innerHTML = '';
      
      if (segments.length === 0) {
        listContainer.innerHTML = '<span class="empty-msg">{{ text_empty_list }}</span>';
        return;
      }

      segments.forEach(function(seg, index) {
        var li = document.createElement('div');
        li.className = 'segment-item';
        
        var dot = document.createElement('span');
        dot.className = 'color-dot';
        dot.style.backgroundColor = seg.color;
        
        var text = document.createTextNode((index + 1) + ". " + seg.seconds + "s");
        
        li.appendChild(dot);
        li.appendChild(text);
        listContainer.appendChild(li);
      });
    }

  })();
</script>