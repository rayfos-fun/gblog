{% assign locale = site.data.locales[page.lang] %}
{% assign game = locale.games.snake %}
{% assign gameTitle = game.title %}
{% assign scoreLabel = locale.score | append: locale.colon %}
{% assign gameOverText = locale.gameover | append: locale.exc %}
{% assign restartButton = locale.restart %}

<style>
  .game-container {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 20px auto;
    width: 400px;
    position: relative; /* For positioning the game-over screen */
    background-color: #f4f4f4;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }

  .game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 15px;
  }

  .game-header h1 {
    font-size: 24px;
    margin: 0;
    color: #333;
  }

  .score-display {
    font-size: 18px;
    font-weight: bold;
    color: #555;
  }

  #game-board {
    background-color: #a8d8a8; /* Light green background */
    border: 2px solid #333;
  }

  #game-over-screen {
    display: none; /* Hidden by default */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    color: white;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    border-radius: 8px; /* Match container */
  }

  #game-over-screen h2 {
    font-size: 32px;
    margin: 0;
  }

  #restart-button {
    font-size: 16px;
    padding: 10px 20px;
    margin-top: 20px;
    background-color: #4CAF50; /* Green */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
  }

  #restart-button:hover {
    background-color: #45a049;
  }
</style>

<div class="game-container">
  <div class="game-header">
    <h1>{{ gameTitle }}</h1>
    <div class="score-display">
      <span id="score-label">{{ scoreLabel }}</span>
      <span id="score-value">0</span>
    </div>
  </div>
  
  <canvas id="game-board" width="400" height="400"></canvas>

  <div id="game-over-screen">
    <h2>{{ gameOverText }}</h2>
    <button id="restart-button">{{ restartButton }}</button>
  </div>
</div>

<script>
  // Wait for the DOM to be fully loaded before running the game script
  document.addEventListener('DOMContentLoaded', () => {

    // --- Game Elements ---
    const canvas = document.getElementById('game-board');
    const ctx = canvas.getContext('2d');
    const scoreValueElement = document.getElementById('score-value');
    const gameOverScreen = document.getElementById('game-over-screen');
    const restartButton = document.getElementById('restart-button');

    // --- Game Constants ---
    const gridSize = 20; // Size of each square in the grid
    const tileCount = canvas.width / gridSize; // 400 / 20 = 20 tiles

    // --- Game State Variables ---
    let snake;
    let food;
    let direction;
    let score;
    let gameLoopInterval;
    let isGameOver;
    let changingDirection; // To prevent 180-degree turns

    // --- Game Functions ---

    /**
     * Initializes or resets the game state
     */
    function startGame() {
      // Initial snake position (center of the board)
      snake = [
        { x: 10, y: 10 },
        { x: 9, y: 10 },
        { x: 8, y: 10 }
      ];
      
      // Initial direction
      direction = { x: 1, y: 0 }; // Moving right
      
      // Reset score
      score = 0;
      scoreValueElement.textContent = score;
      
      // Game state
      isGameOver = false;
      changingDirection = false;
      
      // Hide game over screen
      gameOverScreen.style.display = 'none';

      // Generate the first food item
      generateFood();

      // Clear any existing game loop
      if (gameLoopInterval) {
        clearInterval(gameLoopInterval);
      }
      
      // Start the game loop
      gameLoopInterval = setInterval(gameLoop, 100); // Game ticks every 100ms
    }

    /**
     * The main game loop, called by setInterval
     */
    function gameLoop() {
      if (isGameOver) {
        return;
      }
      
      changingDirection = false; // Allow next input
      clearCanvas();
      moveSnake();
      checkCollisions();
      
      // Only draw if the game is not over
      if (!isGameOver) {
        drawFood();
        drawSnake();
      }
    }

    /**
     * Clears the canvas for the next frame
     */
    function clearCanvas() {
      // Use the background color from CSS
      ctx.fillStyle = '#a8d8a8'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    /**
     * Draws the snake on the canvas
     */
    function drawSnake() {
      ctx.fillStyle = '#333'; // Snake color
      snake.forEach((segment, index) => {
        // Make the head a different color
        ctx.fillStyle = (index === 0) ? '#222' : '#333';
        ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
        // Add a small border to segments
        ctx.strokeStyle = '#a8d8a8'; 
        ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
      });
    }

    /**
     * Draws the food on the canvas
     */
    function drawFood() {
      ctx.fillStyle = '#d9534f'; // Food color (red)
      ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
    }

    /**
     * Updates the snake's position
     */
    function moveSnake() {
      // Create a new head based on the current direction
      const head = { 
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y 
      };
      
      // Add the new head to the beginning of the snake array
      snake.unshift(head);

      // Check if the snake ate the food
      if (head.x === food.x && head.y === food.y) {
        // Ate food
        score += 10;
        scoreValueElement.textContent = score;
        generateFood(); // Generate new food
      } else {
        // Didn't eat food, remove the tail segment
        snake.pop();
      }
    }

    /**
     * Checks for wall or self-collisions
     */
    function checkCollisions() {
      const head = snake[0];

      // Check wall collision
      if (
        head.x < 0 || 
        head.x >= tileCount || 
        head.y < 0 || 
        head.y >= tileCount
      ) {
        endGame();
        return;
      }

      // Check self-collision (check if head hits any part of the tail)
      for (let i = 1; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) {
          endGame();
          return;
        }
      }
    }

    /**
     * Generates a new food item at a random location
     */
    function generateFood() {
      let newFoodPosition;
      while (true) {
        // Create random coordinates
        newFoodPosition = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount)
        };
        
        // Check if the new position is on the snake
        let collision = false;
        for (let segment of snake) {
          if (segment.x === newFoodPosition.x && segment.y === newFoodPosition.y) {
            collision = true;
            break;
          }
        }
        
        // If no collision, this is a valid spot
        if (!collision) {
          food = newFoodPosition;
          return;
        }
      }
    }

    /**
     * Handles the 'Game Over' state
     */
    function endGame() {
      isGameOver = true;
      clearInterval(gameLoopInterval);
      gameOverScreen.style.display = 'flex';
    }

    /**
     * Handles keyboard input to change direction
     */
    function handleKeydown(e) {
      if (changingDirection || isGameOver) {
        return;
      }
      changingDirection = true;

      const keyPressed = e.key;
      
      // Prevent 180-degree turns
      const goingUp = (direction.y === -1);
      const goingDown = (direction.y === 1);
      const goingLeft = (direction.x === -1);
      const goingRight = (direction.x === 1);

      if ((keyPressed === 'ArrowLeft' || keyPressed.toLowerCase() === 'a') && !goingRight) {
        direction = { x: -1, y: 0 };
      } else if ((keyPressed === 'ArrowUp' || keyPressed.toLowerCase() === 'w') && !goingDown) {
        direction = { x: 0, y: -1 };
      } else if ((keyPressed === 'ArrowRight' || keyPressed.toLowerCase() === 'd') && !goingLeft) {
        direction = { x: 1, y: 0 };
      } else if ((keyPressed === 'ArrowDown' || keyPressed.toLowerCase() === 's') && !goingUp) {
        direction = { x: 0, y: 1 };
      } else {
        // If an invalid key or a 180-turn was attempted, allow next input
        changingDirection = false;
      }
    }

    // --- Event Listeners ---
    document.addEventListener('keydown', handleKeydown);
    restartButton.addEventListener('click', startGame);

    // --- Start the game ---
    startGame();
  });
</script>
