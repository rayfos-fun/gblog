{% assign locale = site.data.locales[page.lang] %}
{% assign game = locale.games.minesweeper %}
{% assign game_title = game.title %}
{% assign label_mines = game.label_mines %}
{% assign label_time = locale.time %}
{% assign btn_reset = locale.restart %}
{% assign msg_win = locale.congratulations_you_won %}
{% assign msg_lose = game.msg_lose %}
{% assign msg_start_hint = game.msg_start_hint %}

<style>
  .game-container {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #f0f0f0;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    max-width: 100%;
    box-sizing: border-box;
    user-select: none; /* Prevent text selection */
  }

  .ms-header {
    display: flex;
    justify-content: space-between;
    width: 100%;
    max-width: 360px;
    margin-bottom: 15px;
    background: #fff;
    padding: 10px;
    border-radius: 4px;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
  }

  .ms-stat {
    text-align: center;
    font-size: 0.9rem;
    color: #555;
  }

  .ms-stat span {
    display: block;
    font-weight: bold;
    font-size: 1.2rem;
    color: #333;
  }

  .ms-grid {
    display: grid;
    /* Grid columns will be set by JS */
    gap: 2px;
    background-color: #bbbbbb;
    border: 4px solid #999;
    margin-bottom: 20px;
  }

  .ms-cell {
    width: 30px;
    height: 30px;
    background-color: #c0c0c0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    cursor: pointer;
    font-size: 18px;
    border-top: 3px solid #fff;
    border-left: 3px solid #fff;
    border-right: 3px solid #808080;
    border-bottom: 3px solid #808080;
    box-sizing: border-box;
  }

  .ms-cell:active:not(.revealed) {
    border: 1px solid #999; /* Pressed effect */
  }

  .ms-cell.revealed {
    background-color: #e0e0e0;
    border: 1px solid #ccc;
  }

  .ms-cell.mine {
    background-color: #ff4d4d;
    border: 1px solid #cc0000;
  }

  .ms-cell.flagged {
    color: #e74c3c;
  }

  /* Number colors */
  .ms-cell[data-num="1"] { color: #0000ff; }
  .ms-cell[data-num="2"] { color: #008000; }
  .ms-cell[data-num="3"] { color: #ff0000; }
  .ms-cell[data-num="4"] { color: #000080; }
  .ms-cell[data-num="5"] { color: #800000; }
  .ms-cell[data-num="6"] { color: #008080; }
  .ms-cell[data-num="7"] { color: #000000; }
  .ms-cell[data-num="8"] { color: #808080; }

  .ms-controls {
    text-align: center;
    width: 100%;
  }

  .ms-btn {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.2s;
  }

  .ms-btn:hover {
    background-color: #45a049;
  }

  .ms-message {
    margin-top: 10px;
    font-weight: bold;
    min-height: 24px;
    color: #333;
  }
  
  /* Responsive tweak */
  @media (max-width: 400px) {
    .ms-cell {
      width: 25px;
      height: 25px;
      font-size: 14px;
      border-width: 2px;
    }
  }
</style>

<div class="game-container">
  <h2>{{ game_title }}</h2>
  
  <div class="ms-header">
    <div class="ms-stat">
      {{ label_mines }}
      <span id="ms-mine-count">0</span>
    </div>
    <div class="ms-stat">
      {{ label_time }}
      <span id="ms-timer">000</span>
    </div>
  </div>

  <div id="ms-grid" class="ms-grid"></div>

  <div class="ms-message" id="ms-message">{{ msg_start_hint }}</div>

  <div class="ms-controls">
    <button id="ms-restart-btn" class="ms-btn">{{ btn_reset }}</button>
  </div>
</div>

<script>
  (function() {
    // --- Configuration ---
    const ROWS = 10;
    const COLS = 10;
    const MINES_COUNT = 12; // Difficulty adjustment

    // --- State Variables ---
    let grid = []; // Stores cell data { isMine, isRevealed, isFlagged, neighborCount }
    let isGameOver = false;
    let isFirstClick = true;
    let flagsPlaced = 0;
    let timeElapsed = 0;
    let timerInterval = null;

    // --- DOM Elements ---
    const gridEl = document.getElementById('ms-grid');
    const mineCountEl = document.getElementById('ms-mine-count');
    const timerEl = document.getElementById('ms-timer');
    const msgEl = document.getElementById('ms-message');
    const restartBtn = document.getElementById('ms-restart-btn');

    // --- Localization Strings (injected from Liquid) ---
    const TEXT_WIN = "{{ msg_win }}";
    const TEXT_LOSE = "{{ msg_lose }}";
    const TEXT_HINT = "{{ msg_start_hint }}";

    // --- Initialization ---
    function initGame() {
      // Reset state
      grid = [];
      isGameOver = false;
      isFirstClick = true;
      flagsPlaced = 0;
      timeElapsed = 0;
      
      stopTimer();
      timerEl.textContent = '000';
      updateMineCounter();
      msgEl.textContent = TEXT_HINT;
      msgEl.style.color = '#333';

      // Clear grid UI
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;

      // Create grid data and UI
      for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
          const cellData = {
            r: r,
            c: c,
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            neighborCount: 0
          };
          row.push(cellData);

          // Create DOM element
          const cellEl = document.createElement('div');
          cellEl.classList.add('ms-cell');
          cellEl.dataset.r = r;
          cellEl.dataset.c = c;
          
          // Event Listeners
          cellEl.addEventListener('click', () => handleLeftClick(r, c));
          cellEl.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            handleRightClick(r, c);
          });

          gridEl.appendChild(cellEl);
        }
        grid.push(row);
      }
    }

    // --- Game Logic ---

    function startTimer() {
      stopTimer();
      timerInterval = setInterval(() => {
        timeElapsed++;
        // Format to 3 digits
        timerEl.textContent = timeElapsed.toString().padStart(3, '0');
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // Place mines randomly, ensuring the first clicked cell is safe
    function placeMines(safeR, safeC) {
      let minesPlaced = 0;
      while (minesPlaced < MINES_COUNT) {
        const r = Math.floor(Math.random() * ROWS);
        const c = Math.floor(Math.random() * COLS);

        // Don't place mine at the safe spot or its immediate neighbors (optional, but nicer)
        // For simplicity, we just ensure exact spot is safe
        if ((r === safeR && c === safeC) || grid[r][c].isMine) {
          continue;
        }

        grid[r][c].isMine = true;
        minesPlaced++;
      }

      // Calculate neighbor counts
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!grid[r][c].isMine) {
            grid[r][c].neighborCount = countMinesAround(r, c);
          }
        }
      }
    }

    function countMinesAround(r, c) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          const nr = r + i;
          const nc = c + j;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
            if (grid[nr][nc].isMine) count++;
          }
        }
      }
      return count;
    }

    function handleLeftClick(r, c) {
      if (isGameOver) return;
      
      const cell = grid[r][c];
      
      // Cannot click flagged cells
      if (cell.isFlagged || cell.isRevealed) return;

      // First click logic
      if (isFirstClick) {
        isFirstClick = false;
        startTimer();
        placeMines(r, c);
      }

      // Hit a mine
      if (cell.isMine) {
        gameOver(false);
        return;
      }

      // Reveal cell
      revealCell(r, c);
      
      // Check win
      checkWin();
    }

    function handleRightClick(r, c) {
      if (isGameOver || grid[r][c].isRevealed) return;

      const cell = grid[r][c];
      const cellEl = getCellEl(r, c);

      if (cell.isFlagged) {
        cell.isFlagged = false;
        flagsPlaced--;
        cellEl.classList.remove('flagged');
        cellEl.innerHTML = '';
      } else {
        if (flagsPlaced < MINES_COUNT) {
          cell.isFlagged = true;
          flagsPlaced++;
          cellEl.classList.add('flagged');
          cellEl.innerHTML = 'ðŸš©';
        }
      }
      updateMineCounter();
    }

    // Recursive Reveal (Flood Fill)
    function revealCell(r, c) {
      // Bounds check and state check
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
      const cell = grid[r][c];
      if (cell.isRevealed || cell.isFlagged) return;

      cell.isRevealed = true;
      const cellEl = getCellEl(r, c);
      cellEl.classList.add('revealed');

      if (cell.neighborCount > 0) {
        cellEl.textContent = cell.neighborCount;
        cellEl.dataset.num = cell.neighborCount;
      } else {
        // Empty cell, auto-reveal neighbors
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            revealCell(r + i, c + j);
          }
        }
      }
    }

    function getCellEl(r, c) {
      // The grid has flat children, calculate index
      // Alternatively, use querySelector based on data attr
      return gridEl.children[r * COLS + c];
    }

    function updateMineCounter() {
      mineCountEl.textContent = MINES_COUNT - flagsPlaced;
    }

    function checkWin() {
      let revealedCount = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c].isRevealed) revealedCount++;
        }
      }
      
      // Win condition: All non-mine cells are revealed
      const totalCells = ROWS * COLS;
      if (revealedCount === totalCells - MINES_COUNT) {
        gameOver(true);
      }
    }

    function gameOver(win) {
      isGameOver = true;
      stopTimer();

      if (win) {
        msgEl.textContent = TEXT_WIN;
        msgEl.style.color = 'green';
        // Flag all mines visually
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (grid[r][c].isMine) {
              const el = getCellEl(r, c);
              if (!grid[r][c].isFlagged) {
                el.innerHTML = 'ðŸš©';
                el.classList.add('flagged');
              }
            }
          }
        }
      } else {
        msgEl.textContent = TEXT_LOSE;
        msgEl.style.color = 'red';
        // Reveal all mines
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (grid[r][c].isMine) {
              const el = getCellEl(r, c);
              el.classList.add('mine');
              el.innerHTML = 'ðŸ’£';
            }
          }
        }
      }
    }

    // --- Boot ---
    restartBtn.addEventListener('click', initGame);
    initGame();

  })();
</script>