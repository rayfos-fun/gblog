{% assign locale = site.data.locales[page.lang] %}
{% assign game = locale.games.peg_solitaire %}
{% assign game_title = game.title %}
{% assign txt_remaining = game.txt_remaining %}
{% assign btn_restart = locale.restart %}
{% assign msg_win = locale.congratulations_you_won %}
{% assign msg_game_over = game.msg_game_over %}
{% assign msg_select_peg = game.msg_select_peg %}

<style>
  /* Game Container to isolate styles */
  .game-container {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background-color: #f4f4f9;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    max-width: 500px;
    margin: 20px auto;
  }

  .game-header {
    text-align: center;
    margin-bottom: 20px;
  }

  .game-title {
    font-size: 24px;
    font-weight: bold;
    color: #333;
    margin: 0 0 10px 0;
  }

  .game-stats {
    font-size: 18px;
    color: #555;
  }

  /* The Board Grid: 7x7 layout */
  .solitaire-board {
    display: grid;
    grid-template-columns: repeat(7, 40px);
    grid-template-rows: repeat(7, 40px);
    gap: 5px;
    background-color: #deb887; /* Wooden board color */
    padding: 10px;
    border-radius: 8px;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
  }

  .cell {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
  }

  /* Invalid corners (invisible) */
  .cell.invalid {
    background-color: transparent;
    cursor: default;
    pointer-events: none;
  }

  /* Holes */
  .cell.hole {
    background-color: #5c4033; /* Dark hole */
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
  }

  /* Pegs */
  .peg {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #ff6b6b, #c0392b);
    box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
    transition: transform 0.2s, box-shadow 0.2s;
    pointer-events: none; /* Let clicks pass to the cell */
  }

  /* Selected Peg */
  .cell.selected .peg {
    background: radial-gradient(circle at 30% 30%, #4ecdc4, #1abc9c);
    transform: scale(1.1);
    box-shadow: 0 0 10px #4ecdc4;
  }

  /* Valid Move Hint (Optional visual cue) */
  .cell.valid-target {
    background-color: #6d5448;
    box-shadow: inset 0 0 5px #ffd700;
  }

  .game-controls {
    margin-top: 20px;
    text-align: center;
  }

  .btn-restart {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  .btn-restart:hover {
    background-color: #2980b9;
  }

  .message-area {
    margin-top: 15px;
    height: 24px;
    font-weight: bold;
    color: #e74c3c;
  }

  /* Responsive adjustments */
  @media (max-width: 400px) {
    .solitaire-board {
      grid-template-columns: repeat(7, 35px);
      grid-template-rows: repeat(7, 35px);
    }
    .cell { width: 35px; height: 35px; }
    .peg { width: 28px; height: 28px; }
  }
</style>

<div class="game-container">
  <div class="game-header">
    <div class="game-title">{{ game_title }}</div>
    <div class="game-stats">
      {{ txt_remaining }} <span id="peg-count">32</span>
    </div>
  </div>

  <div id="board" class="solitaire-board">
    </div>

  <div class="message-area" id="game-message"></div>

  <div class="game-controls">
    <button class="btn-restart" onclick="solitaireGame.init()">{{ btn_restart }}</button>
  </div>
</div>

<script>
  /**
   * Peg Solitaire Game Logic
   * Uses a 7x7 grid representation.
   * -1: Invalid (corners)
   * 0: Empty Hole
   * 1: Peg
   */
  const solitaireGame = (function() {
    // DOM Elements
    const boardEl = document.getElementById('board');
    const pegCountEl = document.getElementById('peg-count');
    const messageEl = document.getElementById('game-message');

    // Game State
    let grid = [];
    let selected = null; // {r, c}
    let pegsRemaining = 32;
    let isGameOver = false;

    // Board configuration (0: invalid, 1: valid hole)
    // English style cross board
    const boardMap = [
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 1, 1, 0, 0],
      [1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1], // Center is at 3,3
      [1, 1, 1, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 1, 1, 0, 0]
    ];

    /**
     * Initialize the game
     */
    function init() {
      grid = [];
      pegsRemaining = 0;
      selected = null;
      isGameOver = false;
      messageEl.textContent = '';
      messageEl.style.color = '#e74c3c';

      // Build initial grid state
      for (let r = 0; r < 7; r++) {
        let row = [];
        for (let c = 0; c < 7; c++) {
          if (boardMap[r][c] === 0) {
            row.push(-1); // Wall/Invalid
          } else {
            // Center (3,3) starts empty, others full
            if (r === 3 && c === 3) {
              row.push(0); // Empty
            } else {
              row.push(1); // Peg
              pegsRemaining++;
            }
          }
        }
        grid.push(row);
      }
      
      updateStats();
      render();
    }

    /**
     * Render the board to HTML
     */
    function render() {
      boardEl.innerHTML = '';
      
      for (let r = 0; r < 7; r++) {
        for (let c = 0; c < 7; c++) {
          const cellVal = grid[r][c];
          const cellDiv = document.createElement('div');
          
          if (cellVal === -1) {
            cellDiv.className = 'cell invalid';
          } else {
            cellDiv.className = 'cell hole';
            cellDiv.dataset.r = r;
            cellDiv.dataset.c = c;
            
            // Add click listener
            cellDiv.onclick = () => handleCellClick(r, c);

            // Add peg if present
            if (cellVal === 1) {
              const pegDiv = document.createElement('div');
              pegDiv.className = 'peg';
              cellDiv.appendChild(pegDiv);
            }

            // Highlight selected
            if (selected && selected.r === r && selected.c === c) {
              cellDiv.classList.add('selected');
            }
          }
          boardEl.appendChild(cellDiv);
        }
      }
    }

    /**
     * Handle user interaction
     */
    function handleCellClick(r, c) {
      if (isGameOver) return;

      const val = grid[r][c];

      // Case 1: Click on a peg -> Select it
      if (val === 1) {
        selected = { r, c };
        messageEl.textContent = ''; // Clear error messages
        render(); // Re-render to show selection
      }
      // Case 2: Click on an empty hole -> Try to move selected peg there
      else if (val === 0 && selected) {
        attemptMove(selected.r, selected.c, r, c);
      }
    }

    /**
     * Attempt to move a peg
     */
    function attemptMove(r1, c1, r2, c2) {
      // Check orthogonality (same row or same col)
      if (r1 !== r2 && c1 !== c2) return;

      // Check distance (must be exactly 2 spaces)
      const dist = Math.abs(r1 - r2) + Math.abs(c1 - c2);
      if (dist !== 2) return;

      // Calculate middle coordinate
      const midR = (r1 + r2) / 2;
      const midC = (c1 + c2) / 2;

      // Check if there is a peg to jump over
      if (grid[midR][midC] !== 1) return;

      // Execute Move
      grid[r1][c1] = 0; // Source becomes empty
      grid[midR][midC] = 0; // Middle (jumped) becomes empty
      grid[r2][c2] = 1; // Destination gets peg

      // Update State
      pegsRemaining--;
      selected = null; // Deselect
      updateStats();
      render();
      checkWinCondition();
    }

    /**
     * Update UI counters
     */
    function updateStats() {
      pegCountEl.textContent = pegsRemaining;
    }

    /**
     * Check for Win or Loss
     */
    function checkWinCondition() {
      if (pegsRemaining === 1) {
        // Victory
        isGameOver = true;
        messageEl.textContent = "{{ msg_win }}";
        messageEl.style.color = '#27ae60';
        return;
      }

      // Check if any moves are possible
      if (!hasPossibleMoves()) {
        isGameOver = true;
        messageEl.textContent = "{{ msg_game_over }}";
      }
    }

    /**
     * Scan board to see if any move is possible
     */
    function hasPossibleMoves() {
      const directions = [
        [0, 2], [0, -2], [2, 0], [-2, 0] // Right, Left, Down, Up (2 steps)
      ];

      for (let r = 0; r < 7; r++) {
        for (let c = 0; c < 7; c++) {
          // If there is a peg here, check if it can jump anywhere
          if (grid[r][c] === 1) {
            for (let d of directions) {
              const destR = r + d[0];
              const destC = c + d[1];
              const midR = r + (d[0] / 2);
              const midC = c + (d[1] / 2);

              // Check boundaries
              if (destR >= 0 && destR < 7 && destC >= 0 && destC < 7) {
                // Logic: Destination is Empty AND Middle is Peg AND Destination is valid board space
                if (grid[destR][destC] === 0 && grid[midR][midC] === 1) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }

    // Initialize on load
    init();

    // Expose init for restart button
    return {
      init: init
    };
  })();
</script>