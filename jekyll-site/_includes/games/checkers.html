{% assign locale = site.data.locales[page.lang] %}
{% assign game = site.data.locales[page.lang].games.checkers %}

<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
  body {
  }
  .game-container {
    font-family: 'Inter', sans-serif;
    background-color: #f7f7f7;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
    background-color: #fff;
    padding: 20px;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    max-width: 90vw;
    min-height: 100vh;
    margin: 0;
  }
  canvas {
    border: 4px solid #333;
    border-radius: 8px;
    touch-action: none; /* Prevent browser scrolling on touch */
  }
  .status-box {
    width: 100%;
    text-align: center;
    margin-top: 15px;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1em;
    background-color: #e9ecef;
    color: #333;
    min-height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .button-group {
    display: flex;
    gap: 10px;
    margin-top: 15px;
  }
  .restart-button {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.2s, transform 0.1s;
    box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
  }
  .restart-button:hover {
    background-color: #0056b3;
    transform: translateY(-1px);
  }
</style>

<div class="game-container">
  <h1 class="text-2xl font-bold mb-4 text-gray-800">{{ game.title }}</h1>
  <canvas id="checkersCanvas"></canvas>
  <div id="status" class="status-box">{{ game.status_init }}</div>
  <div class="button-group">
    <button class="restart-button" onclick="initGame()">{{ locale.restart }}</button>
  </div>
</div>

<script>
  // --- 遊戲設定與狀態 ---
  const CANVAS_SIZE = 560; // 棋盤大小 (8x8)
  const BOARD_SIZE = 8;
  const SQUARE_SIZE = CANVAS_SIZE / BOARD_SIZE;
  const PIECE_RADIUS = SQUARE_SIZE / 2 * 0.8;

  const LIGHT_COLOR = "#f0d2b2"; // 淺色方塊
  const DARK_COLOR = "#a0522d"; // 深色方塊 (可移動的方塊)
  const SELECTED_COLOR = "rgba(0, 255, 0, 0.5)"; // 選中方塊顏色
  const JUMP_COLOR = "rgba(255, 165, 0, 0.6)"; // 強制跳躍提示顏色

  const PLAYER_1 = 1; // 紅色 (底排)
  const PLAYER_2 = 2; // 黑色 (頂排)

  const canvas = document.getElementById('checkersCanvas');
  const ctx = canvas.getContext('2d');
  const statusDisplay = document.getElementById('status');

  canvas.width = CANVAS_SIZE;
  canvas.height = CANVAS_SIZE;

  let board = [];
  let currentPlayer = PLAYER_1;
  let selectedPiece = null; // { row, col }
  let mustJump = false;
  let jumpSequences = []; // 儲存所有可行的跳躍路徑

  // --- 輔助函數：初始化與繪圖 ---

  function initGame() {
    // 棋盤初始化：0=空, 1=紅棋, 2=黑棋, 3=紅王, 4=黑王
    board = Array(BOARD_SIZE).fill(0).map((_, row) => {
      return Array(BOARD_SIZE).fill(0).map((_, col) => {
        // 只有深色方塊上可以放棋子 (row + col) % 2 == 1
        if ((row + col) % 2 === 1) {
          if (row < 3) return PLAYER_2; // 黑色 (Player 2)
          if (row > 4) return PLAYER_1; // 紅色 (Player 1)
        }
        return 0;
      });
    });

    currentPlayer = PLAYER_1;
    selectedPiece = null;
    mustJump = false;
    jumpSequences = [];

    // 確保點擊處理器被啟用 (若先前因遊戲結束而被移除)
    canvas.removeEventListener('click', handleCanvasClick); // 移除舊的 (如果存在)
    canvas.addEventListener('click', handleCanvasClick); // 加入新的

    updateStatus();
    drawBoard();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

    // 繪製棋盤方塊
    for (let row = 0; row < BOARD_SIZE; row++) {
      for (let col = 0; col < BOARD_SIZE; col++) {
        const color = (row + col) % 2 === 0 ? LIGHT_COLOR : DARK_COLOR;
        ctx.fillStyle = color;
        ctx.fillRect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);

        // 繪製選中的方塊
        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
          ctx.fillStyle = SELECTED_COLOR;
          ctx.fillRect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        }
      }
    }

    // 檢查並繪製強制跳躍的提示 (只在回合開始時執行一次)
    if (!selectedPiece && !mustJump) {
      jumpSequences = findAllJumps(currentPlayer);
      mustJump = jumpSequences.length > 0;
    }

    if (mustJump) {
      // 提示所有可以開始跳躍的棋子
      const startPositions = new Set(jumpSequences.map(seq => `${seq[0].row},${seq[0].col}`));
      startPositions.forEach(pos => {
        const [row, col] = pos.split(',').map(Number);
        ctx.fillStyle = JUMP_COLOR;
        ctx.fillRect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      });

      // 如果有選中的棋子，且它在可跳躍的列表中，則高亮可落子的位置
      if (selectedPiece) {
        highlightValidJumps(selectedPiece.row, selectedPiece.col);
      }
    }


    // 繪製棋子
    for (let row = 0; row < BOARD_SIZE; row++) {
      for (let col = 0; col < BOARD_SIZE; col++) {
        const piece = board[row][col];
        if (piece !== 0) {
          const centerX = col * SQUARE_SIZE + SQUARE_SIZE / 2;
          const centerY = row * SQUARE_SIZE + SQUARE_SIZE / 2;

          ctx.beginPath();
          ctx.arc(centerX, centerY, PIECE_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = (piece === PLAYER_1 || piece === 3) ? '#dc3545' : '#343a40'; // 紅色或深灰
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.fill();
          ctx.stroke();

          // 繪製王棋標記 (King)
          if (piece === 3 || piece === 4) {
            ctx.fillStyle = 'gold';
            ctx.font = `${PIECE_RADIUS}px Inter`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('★', centerX, centerY);
          }
        }
      }
    }
  }

  function highlightValidJumps(sRow, sCol) {
    // 找到從 (sRow, sCol) 開始的所有跳躍路徑的下一步位置
    jumpSequences
      .filter(seq => seq[0].row === sRow && seq[0].col === sCol)
      .map(seq => seq[1]) // 第二個元素是目標位置
      .forEach(target => {
        const tRow = target.row;
        const tCol = target.col;
        ctx.fillStyle = JUMP_COLOR;
        ctx.fillRect(tCol * SQUARE_SIZE, tRow * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      });
  }


  function updateStatus(message) {
    const playerColor = currentPlayer === PLAYER_1 ? '{{ game.player1 }}' : '{{ game.player2 }}';
    const defaultMessage = `{{ game.status }}`;

    if (mustJump && !message) {
       statusDisplay.innerHTML = `<span style="color: red;">{{ game.must_jump }}</span> {{ game.status }}`;
    } else if (message) {
      statusDisplay.textContent = message;
    } else {
      statusDisplay.textContent = defaultMessage;
    }

    drawBoard();
  }

  function checkForGameOver() {
    let redPieces = 0;
    let blackPieces = 0;
    for (let row = 0; row < BOARD_SIZE; row++) {
      for (let col = 0; col < BOARD_SIZE; col++) {
        const piece = board[row][col];
        if (piece === 1 || piece === 3) redPieces++;
        if (piece === 2 || piece === 4) blackPieces++;
      }
    }

    if (redPieces === 0) {
      updateStatus('{{ locale.gameover }}{{ locale.exc }}{{ game.player2 }}{{ locale.sep }}{{ locale.win }}{{ locale.exc }}');
      canvas.removeEventListener('click', handleCanvasClick); // FIX: 修正為 removeEventListener
    } else if (blackPieces === 0) {
      updateStatus('{{ locale.gameover }}{{ locale.exc }}{{ game.player1 }}{{ locale.sep }}{{ locale.win }}{{ locale.exc }}');
      canvas.removeEventListener('click', handleCanvasClick); // FIX: 修正為 removeEventListener
    }
  }

  // --- 遊戲邏輯：移動與跳躍 ---

  // 檢查單一步驟是否為有效的跳躍
  function isValidJump(sRow, sCol, tRow, tCol) {
    const piece = board[sRow][sCol];
    if (piece === 0) return null;

    const isKing = piece === 3 || piece === 4;
    // 修正方向邏輯: P1(紅, 1/3)從下往上(row變小, dRow/2 = -1), P2(黑, 2/4)從上往下(row變大, dRow/2 = 1)
    const expectedJumpDelta = (piece === PLAYER_1 || piece === 3) ? -1 : 1; 
    const opponent = (piece === 1 || piece === 3) ? PLAYER_2 : PLAYER_1;

    const dRow = tRow - sRow;
    const dCol = tCol - sCol;

    // 必須是跳兩格 (dRow和dCol都是2或-2)
    if (Math.abs(dRow) !== 2 || Math.abs(dCol) !== 2) return null;

    // 檢查移動方向 (非王棋只能向前)
    if (!isKing && (dRow / 2) !== expectedJumpDelta) return null;

    // 檢查中間的棋子
    const jumpedRow = sRow + dRow / 2;
    const jumpedCol = sCol + dCol / 2;
    const jumpedPiece = board[jumpedRow][jumpedCol];

    // 中間必須是敵方棋子 (1或3 對 2或4)
    if (!(jumpedPiece === opponent || jumpedPiece === opponent + 2)) return null;

    // 目標位置必須為空
    if (board[tRow][tCol] !== 0) return null;

    // 返回被吃掉的棋子位置
    return { row: jumpedRow, col: jumpedCol };
  }

  // 檢查單一步驟是否為有效的移動 (非跳躍)
  function isValidMove(sRow, sCol, tRow, tCol) {
    const piece = board[sRow][sCol];
    if (piece === 0) return false;

    const isKing = piece === 3 || piece === 4;
    const direction = piece === PLAYER_1 || piece === 3 ? 1 : -1; // P1(紅)從下往上(-1), P2(黑)從上往下(+1)

    const dRow = tRow - sRow;
    const dCol = Math.abs(tCol - sCol);

    // 必須是移動一格 (dRow是1或-1, dCol是1)
    if (Math.abs(dRow) !== 1 || dCol !== 1) return false;

    // 檢查移動方向 (非王棋只能向前)
    // 注意：這裡P1(紅)是從7往0走，所以dRow是負數。P2(黑)是從0往7走，所以dRow是正數。
    const expectedDirection = (currentPlayer === PLAYER_1) ? -1 : 1;
     if (!isKing && dRow !== expectedDirection) return false;

    // 目標位置必須為空
    if (board[tRow][tCol] !== 0) return false;

    return true;
  }

  // 找到所有可行的跳躍 (用於強制跳躍檢查)
  function findAllJumps(player) {
    let allJumps = [];
    for (let sRow = 0; sRow < BOARD_SIZE; sRow++) {
      for (let sCol = 0; sCol < BOARD_SIZE; sCol++) {
        const piece = board[sRow][sCol];
        if (piece === player || piece === player + 2) { // 找到當前玩家的棋子
          const targets = findNextJumps(sRow, sCol);
          targets.forEach(target => {
            allJumps.push([{ row: sRow, col: sCol }, target]);
          });
        }
      }
    }
    return allJumps; // 返回所有 [起始位置, 目標位置] 的陣列
  }

  // 找到從給定位置開始的所有單次跳躍目標
  function findNextJumps(sRow, sCol) {
    let jumps = [];
    const directions = [-1, 1]; // 四個對角方向

    for (const dr of directions) {
      for (const dc of directions) {
        const tRow = sRow + dr * 2;
        const tCol = sCol + dc * 2;

        if (tRow >= 0 && tRow < BOARD_SIZE && tCol >= 0 && tCol < BOARD_SIZE) {
          if (isValidJump(sRow, sCol, tRow, tCol)) {
            jumps.push({ row: tRow, col: tCol });
          }
        }
      }
    }
    return jumps;
  }


  // --- 點擊事件處理 ---

  function handleCanvasClick(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // 計算點擊的行和列
    const col = Math.floor(x / SQUARE_SIZE);
    const row = Math.floor(y / SQUARE_SIZE);

    if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return;

    const piece = board[row][col];
    const isCurrentPlayer = piece === currentPlayer || piece === currentPlayer + 2; // 玩家的普通棋或王棋

    if (selectedPiece === null) {
      // 1. 選擇棋子
      if (isCurrentPlayer) {
        if (mustJump) {
          // 檢查是否為可以跳躍的棋子
          const canStartJump = jumpSequences.some(seq => seq[0].row === row && seq[0].col === col);
          if (!canStartJump) {
            updateStatus('{{ game.can_not_jump }}');
            return;
          }
        }
        selectedPiece = { row, col };
        updateStatus(); // 重新繪圖以高亮選中的棋子
      } else {
        updateStatus('{{ game.not_yours }}');
      }
    } else {
      // 2. 移動棋子到 (row, col)
      const sRow = selectedPiece.row;
      const sCol = selectedPiece.col;

      if (sRow === row && sCol === col) {
        // 取消選擇
        selectedPiece = null;
        updateStatus();
        return;
      }

      // 嘗試執行跳躍
      const jumpInfo = isValidJump(sRow, sCol, row, col);

      if (jumpInfo) {
        // 是有效的跳躍
        makeMove(sRow, sCol, row, col, jumpInfo);
        // 檢查是否可以繼續跳躍
        const nextJumps = findNextJumps(row, col);
        if (nextJumps.length > 0) {
          // 允許連跳 (必須是剛才移動的棋子)
          selectedPiece = { row, col };
          mustJump = true; // 在連跳模式下，必須繼續跳
          jumpSequences = []; // 重設強制跳躍，只看當前棋子的連跳
          playerColor = currentPlayer === PLAYER_1 ? '{{ game.player1 }}' : '{{ game.player2 }}';
          updateStatus(`{{ game.next_jump }}`);
        } else {
          // 連跳結束，換玩家
          endTurn(row);
        }
      } else if (!mustJump && isValidMove(sRow, sCol, row, col)) {
        // 是有效的普通移動，且沒有強制跳躍
        makeMove(sRow, sCol, row, col);
        endTurn(row);
      } else {
        // 無效操作 (要么是普通移動但有強制跳躍，要么是無效目標)
        let message = '';
        if (mustJump) {
          message = '{{ game.invalid_must_jump }}';
        } else if (isCurrentPlayer) {
           // 重新選擇棋子
          selectedPiece = { row, col };
          message = '{{ game.invalid_pos }}';
        } else {
          message = '{{ game.invalid_click }}';
        }
        updateStatus(message);
      }
    }
  }

  function makeMove(sRow, sCol, tRow, tCol, jumpInfo = null) {
    // 1. 移動棋子
    const piece = board[sRow][sCol];
    board[tRow][tCol] = piece;
    board[sRow][sCol] = 0;

    // 2. 移除被跳過的棋子
    if (jumpInfo) {
      board[jumpInfo.row][jumpInfo.col] = 0;
    }

    // 3. 檢查是否王棋 (Kinging)
    if (piece === PLAYER_1 && tRow === 0) { // 紅棋到達頂端
      board[tRow][tCol] = 3;
    } else if (piece === PLAYER_2 && tRow === 7) { // 黑棋到達底端
      board[tRow][tCol] = 4;
    }
  }

  function endTurn(finalRow) {
    selectedPiece = null;
    mustJump = false; // 重設跳躍狀態
    jumpSequences = []; // 清空連跳路徑
    checkForGameOver();

    // 如果遊戲尚未結束，切換玩家
    if (statusDisplay.textContent.indexOf('{{ locale.gameover }}') === -1) {
      currentPlayer = currentPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;
      updateStatus();
    }
  }

  // --- 遊戲啟動 ---
  window.onload = function() {
    canvas.addEventListener('click', handleCanvasClick);
    initGame();
  }

</script>