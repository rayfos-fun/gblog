---
title: "The \"Silent Killer\" in Your Database: Why RPCs Inside Transactions Are a Ticking Time Bomb"
date: "2025-12-03"
---
Recently, our team's software performance degraded to an excruciating crawl. Bug tickets were flying in like a blizzard, burying the team right before the Thanksgiving holiday. The prospect of a peaceful break was slipping away fast.

We dove into the logs and noticed a massive spike in **Database Transaction Aborts**.

### The Root Cause

After a frantic investigation, we found the culprit: **RPC calls nested inside database transactions.**

These RPCs were sometimes slow or unstable, causing the transactions to hang open for too long. This led to resource contention, deadlocks, and eventually, mass failures. Once we moved the RPCs out of the transaction scope, the system stabilized immediately.

### The "Broken Windows" of Code

We initially wasted time checking recent code commits, but found nothing. It turned out, these RPCs weren't new—they were legacy code.

So why did it break now?
1.  **Uncontrollable Latency:** RPC response times fluctuated.
2.  **Organic Growth:** User traffic increased, exposing concurrency issues that were previously hidden.

In the beginning, inserting an RPC inside a transaction seemed harmless. It was fast enough, and the retry mechanisms masked any occasional aborts. Developers looked at the existing codebase, saw that "everyone else does it," and followed the pattern for convenience.

It was the classic **Boiling Frog** effect. What started as a few snowflakes rolled into a snowball, and finally triggered an avalanche that nearly buried us.

### Lesson Learned

While calling a stateless, low-latency RPC inside a transaction might seem safe in theory, it introduces an external dependency that you cannot control.

**Don't do it.**

This incident taught us a hard lesson: Keep your transactions short and pure. Think twice before mixing external calls with ACID boundaries—your future self (and your holiday plans) will thank you.